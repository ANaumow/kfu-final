## Основная идея фреймворка

Возможность запуска ресурсозатратных сервисов отдельно от основного приложения с обеспечением взаимодействия между ними.

Например, запустим определенный сервис(бин) отдельно от основного приложения:

![1.png](.img%2F1.png)

Таким же образом можно вынести и несколько сильно связных сервисов:

![2.png](.img%2F2.png)

Для работы фреймворка разработчик должен поставить аннотацию `@EnableModules`, которая добавляет в контекст бины для работы фреймворка:

![3.png](.img%2F3.png)

Использование аннотации `@Modular("...")` для обозначения принадлежности сервиса(бина) к определенному модулю:

![4.png](.img%2F4.png)

Таким способом явно указывается какую часть системы нужно масштабировать или просто запустить на другом серевере.

Далее код другого сервиса, который обращается к предыдущему сервису, но теперь он получает не сам объект, а его прокси, методы которого обращаются по HTTP к методам оригинального объекта, находящегося на другом сервере с сериализацией передаваемых параметров и возвращаемого значения:

![5.png](.img%2F5.png)

Обратите внимание: _код сервисов использующий такие удаленные сервисы никак не изменился_.

## Пример запуска приложения

Запуск приложения с главным модулем:

```shell
java -jar app.jar
```

Запуск приложения с конкретным модулем:

```shell
java -jar app.jar --application.module=purchase-module
```


## Реализация

Основной механизм фреймворка - замена оригинального объекта на прокси-объект. Механизм проксирования бинов выглядит следующим образом:
- После инициализации `BeanDefinitionRegistry`, ищем все `BeanDefinition`, которые нужно запроксировать, бины таких `BeanDefinition`'ов помечены аннотацией `@Modular`;
- Заменяем такие `BeanDefinition` на новые `BeanDefinition`, которые вместо оригинального бина будут создавать `FactoryBean` (фабричный бин), который на этапе инициализации контекста будет создавать прокси:

`BeanDefinition[Bean] => BeanDefinition[FactoryBean[ProxyBean]]`

-  Прослойка в виде `FactoryBean` нужна для вмешивания в процесс создания бина; на этом этапе и создается прокси-бин для вызовов удаленно запущенного оригинального бина

Таким образом еще во время сбора информации о бинах(во время инициализации `BeanDefinitionRegistry`) добавляется логика проксирования

Код фреймворка лежит в [./external-lib](./external-lib)

[ModularAnnotationPostProcessor](./external-lib/src/main/java/ru/itis/lib/ModularAnnotationPostProcessor.java) - занимается отлавливанием нужных бинов во время инициализации приложения и заменят их если нужно на прокси

[RemoteModuleFactoryBean](./external-lib/src/main/java/ru/itis/lib/RemoteModuleFactoryBean.java) - фабричный бин, который во время инициализации контекста создает прокси-бин, вызовы методов которого делегируются ModuleProxyHandler

[ModuleProxyHandler](./external-lib/src/main/java/ru/itis/lib/ModuleProxyHandler.java) - занимается вызовом удаленно запущенного оригинального бина и получением от него ответа

[ModularController](./external-lib/src/main/java/ru/itis/lib/ModularController.java) - контроллер в отдельно запущенной части приложения, который отлавливает запрос и вызывает нужный оригинальный бин



